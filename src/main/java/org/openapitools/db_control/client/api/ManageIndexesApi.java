/*
 * Pinecone Control Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.db_control.client.api;

import org.openapitools.db_control.client.ApiCallback;
import org.openapitools.db_control.client.ApiClient;
import org.openapitools.db_control.client.ApiException;
import org.openapitools.db_control.client.ApiResponse;
import org.openapitools.db_control.client.Configuration;
import org.openapitools.db_control.client.Pair;
import org.openapitools.db_control.client.ProgressRequestBody;
import org.openapitools.db_control.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.db_control.client.model.BackupList;
import org.openapitools.db_control.client.model.BackupModel;
import org.openapitools.db_control.client.model.CollectionList;
import org.openapitools.db_control.client.model.CollectionModel;
import org.openapitools.db_control.client.model.ConfigureIndexRequest;
import org.openapitools.db_control.client.model.CreateBackupRequest;
import org.openapitools.db_control.client.model.CreateCollectionRequest;
import org.openapitools.db_control.client.model.CreateIndexForModelRequest;
import org.openapitools.db_control.client.model.CreateIndexFromBackupRequest;
import org.openapitools.db_control.client.model.CreateIndexRequest;
import org.openapitools.db_control.client.model.ErrorResponse;
import org.openapitools.db_control.client.model.IndexList;
import org.openapitools.db_control.client.model.IndexModel;
import org.openapitools.db_control.client.model.RestoreJobList;
import org.openapitools.db_control.client.model.RestoreJobModel;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class ManageIndexesApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public ManageIndexesApi() {
        this(Configuration.getDefaultApiClient());
    }

    public ManageIndexesApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for configureIndex
     * @param indexName The name of the index to configure. (required)
     * @param configureIndexRequest The desired pod size and replica configuration for the index. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The request to configure the index has been accepted. Check the  index status to see when the change has been applied. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. The request body included invalid request parameters. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> Payment required. Organization is on a paid plan and is delinquent on payment. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> You&#39;ve exceed your pod quota. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Index not found. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity. The request body could not be deserialized. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call configureIndexCall(String indexName, ConfigureIndexRequest configureIndexRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = configureIndexRequest;

        // create path and map variables
        String localVarPath = "/indexes/{index_name}"
            .replace("{" + "index_name" + "}", localVarApiClient.escapeString(indexName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PATCH", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call configureIndexValidateBeforeCall(String indexName, ConfigureIndexRequest configureIndexRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'indexName' is set
        if (indexName == null) {
            throw new ApiException("Missing the required parameter 'indexName' when calling configureIndex(Async)");
        }

        // verify the required parameter 'configureIndexRequest' is set
        if (configureIndexRequest == null) {
            throw new ApiException("Missing the required parameter 'configureIndexRequest' when calling configureIndex(Async)");
        }

        return configureIndexCall(indexName, configureIndexRequest, _callback);

    }

    /**
     * Configure an index
     * Configure an existing index. For serverless indexes, you can configure index deletion protection, tags, and integrated inference embedding settings for the index. For pod-based indexes, you can configure the pod size, number of replicas, tags, and index deletion protection.  It is not possible to change the pod type of a pod-based index. However, you can create a collection from a pod-based index and then [create a new pod-based index with a different pod type](http://docs.pinecone.io/guides/indexes/pods/create-a-pod-based-index#create-a-pod-index-from-a-collection) from the collection. For guidance and examples, see [Configure an index](http://docs.pinecone.io/guides/indexes/pods/manage-pod-based-indexes).
     * @param indexName The name of the index to configure. (required)
     * @param configureIndexRequest The desired pod size and replica configuration for the index. (required)
     * @return IndexModel
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The request to configure the index has been accepted. Check the  index status to see when the change has been applied. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. The request body included invalid request parameters. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> Payment required. Organization is on a paid plan and is delinquent on payment. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> You&#39;ve exceed your pod quota. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Index not found. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity. The request body could not be deserialized. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public IndexModel configureIndex(String indexName, ConfigureIndexRequest configureIndexRequest) throws ApiException {
        ApiResponse<IndexModel> localVarResp = configureIndexWithHttpInfo(indexName, configureIndexRequest);
        return localVarResp.getData();
    }

    /**
     * Configure an index
     * Configure an existing index. For serverless indexes, you can configure index deletion protection, tags, and integrated inference embedding settings for the index. For pod-based indexes, you can configure the pod size, number of replicas, tags, and index deletion protection.  It is not possible to change the pod type of a pod-based index. However, you can create a collection from a pod-based index and then [create a new pod-based index with a different pod type](http://docs.pinecone.io/guides/indexes/pods/create-a-pod-based-index#create-a-pod-index-from-a-collection) from the collection. For guidance and examples, see [Configure an index](http://docs.pinecone.io/guides/indexes/pods/manage-pod-based-indexes).
     * @param indexName The name of the index to configure. (required)
     * @param configureIndexRequest The desired pod size and replica configuration for the index. (required)
     * @return ApiResponse&lt;IndexModel&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The request to configure the index has been accepted. Check the  index status to see when the change has been applied. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. The request body included invalid request parameters. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> Payment required. Organization is on a paid plan and is delinquent on payment. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> You&#39;ve exceed your pod quota. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Index not found. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity. The request body could not be deserialized. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<IndexModel> configureIndexWithHttpInfo(String indexName, ConfigureIndexRequest configureIndexRequest) throws ApiException {
        okhttp3.Call localVarCall = configureIndexValidateBeforeCall(indexName, configureIndexRequest, null);
        Type localVarReturnType = new TypeToken<IndexModel>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Configure an index (asynchronously)
     * Configure an existing index. For serverless indexes, you can configure index deletion protection, tags, and integrated inference embedding settings for the index. For pod-based indexes, you can configure the pod size, number of replicas, tags, and index deletion protection.  It is not possible to change the pod type of a pod-based index. However, you can create a collection from a pod-based index and then [create a new pod-based index with a different pod type](http://docs.pinecone.io/guides/indexes/pods/create-a-pod-based-index#create-a-pod-index-from-a-collection) from the collection. For guidance and examples, see [Configure an index](http://docs.pinecone.io/guides/indexes/pods/manage-pod-based-indexes).
     * @param indexName The name of the index to configure. (required)
     * @param configureIndexRequest The desired pod size and replica configuration for the index. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The request to configure the index has been accepted. Check the  index status to see when the change has been applied. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. The request body included invalid request parameters. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> Payment required. Organization is on a paid plan and is delinquent on payment. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> You&#39;ve exceed your pod quota. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Index not found. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity. The request body could not be deserialized. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call configureIndexAsync(String indexName, ConfigureIndexRequest configureIndexRequest, final ApiCallback<IndexModel> _callback) throws ApiException {

        okhttp3.Call localVarCall = configureIndexValidateBeforeCall(indexName, configureIndexRequest, _callback);
        Type localVarReturnType = new TypeToken<IndexModel>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for createBackup
     * @param indexName Name of the index to backup (required)
     * @param createBackupRequest The desired configuration for the backup. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The backup has been successfully created. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. The request body included invalid request parameters. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> Payment required. Organization is on a paid plan and is delinquent on payment. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> You&#39;ve exceed your backup quota. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity. The request body could not be deserialized. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createBackupCall(String indexName, CreateBackupRequest createBackupRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = createBackupRequest;

        // create path and map variables
        String localVarPath = "/indexes/{index_name}/backups"
            .replace("{" + "index_name" + "}", localVarApiClient.escapeString(indexName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createBackupValidateBeforeCall(String indexName, CreateBackupRequest createBackupRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'indexName' is set
        if (indexName == null) {
            throw new ApiException("Missing the required parameter 'indexName' when calling createBackup(Async)");
        }

        // verify the required parameter 'createBackupRequest' is set
        if (createBackupRequest == null) {
            throw new ApiException("Missing the required parameter 'createBackupRequest' when calling createBackup(Async)");
        }

        return createBackupCall(indexName, createBackupRequest, _callback);

    }

    /**
     * Create a backup of an index
     * Create a backup of an index. 
     * @param indexName Name of the index to backup (required)
     * @param createBackupRequest The desired configuration for the backup. (required)
     * @return BackupModel
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The backup has been successfully created. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. The request body included invalid request parameters. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> Payment required. Organization is on a paid plan and is delinquent on payment. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> You&#39;ve exceed your backup quota. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity. The request body could not be deserialized. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public BackupModel createBackup(String indexName, CreateBackupRequest createBackupRequest) throws ApiException {
        ApiResponse<BackupModel> localVarResp = createBackupWithHttpInfo(indexName, createBackupRequest);
        return localVarResp.getData();
    }

    /**
     * Create a backup of an index
     * Create a backup of an index. 
     * @param indexName Name of the index to backup (required)
     * @param createBackupRequest The desired configuration for the backup. (required)
     * @return ApiResponse&lt;BackupModel&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The backup has been successfully created. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. The request body included invalid request parameters. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> Payment required. Organization is on a paid plan and is delinquent on payment. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> You&#39;ve exceed your backup quota. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity. The request body could not be deserialized. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<BackupModel> createBackupWithHttpInfo(String indexName, CreateBackupRequest createBackupRequest) throws ApiException {
        okhttp3.Call localVarCall = createBackupValidateBeforeCall(indexName, createBackupRequest, null);
        Type localVarReturnType = new TypeToken<BackupModel>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create a backup of an index (asynchronously)
     * Create a backup of an index. 
     * @param indexName Name of the index to backup (required)
     * @param createBackupRequest The desired configuration for the backup. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The backup has been successfully created. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. The request body included invalid request parameters. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> Payment required. Organization is on a paid plan and is delinquent on payment. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> You&#39;ve exceed your backup quota. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity. The request body could not be deserialized. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createBackupAsync(String indexName, CreateBackupRequest createBackupRequest, final ApiCallback<BackupModel> _callback) throws ApiException {

        okhttp3.Call localVarCall = createBackupValidateBeforeCall(indexName, createBackupRequest, _callback);
        Type localVarReturnType = new TypeToken<BackupModel>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for createCollection
     * @param createCollectionRequest The desired configuration for the collection. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The collection has been successfully created. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. The request body included invalid request parameters. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> Payment required. Organization is on a paid plan and is delinquent on payment. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> You&#39;ve exceed your collections quota. </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Collection of given name already exists. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity. The request body could not be deserialized. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createCollectionCall(CreateCollectionRequest createCollectionRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = createCollectionRequest;

        // create path and map variables
        String localVarPath = "/collections";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createCollectionValidateBeforeCall(CreateCollectionRequest createCollectionRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'createCollectionRequest' is set
        if (createCollectionRequest == null) {
            throw new ApiException("Missing the required parameter 'createCollectionRequest' when calling createCollection(Async)");
        }

        return createCollectionCall(createCollectionRequest, _callback);

    }

    /**
     * Create a collection
     * Create a Pinecone collection.    Serverless indexes do not support collections. 
     * @param createCollectionRequest The desired configuration for the collection. (required)
     * @return CollectionModel
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The collection has been successfully created. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. The request body included invalid request parameters. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> Payment required. Organization is on a paid plan and is delinquent on payment. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> You&#39;ve exceed your collections quota. </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Collection of given name already exists. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity. The request body could not be deserialized. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public CollectionModel createCollection(CreateCollectionRequest createCollectionRequest) throws ApiException {
        ApiResponse<CollectionModel> localVarResp = createCollectionWithHttpInfo(createCollectionRequest);
        return localVarResp.getData();
    }

    /**
     * Create a collection
     * Create a Pinecone collection.    Serverless indexes do not support collections. 
     * @param createCollectionRequest The desired configuration for the collection. (required)
     * @return ApiResponse&lt;CollectionModel&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The collection has been successfully created. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. The request body included invalid request parameters. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> Payment required. Organization is on a paid plan and is delinquent on payment. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> You&#39;ve exceed your collections quota. </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Collection of given name already exists. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity. The request body could not be deserialized. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CollectionModel> createCollectionWithHttpInfo(CreateCollectionRequest createCollectionRequest) throws ApiException {
        okhttp3.Call localVarCall = createCollectionValidateBeforeCall(createCollectionRequest, null);
        Type localVarReturnType = new TypeToken<CollectionModel>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create a collection (asynchronously)
     * Create a Pinecone collection.    Serverless indexes do not support collections. 
     * @param createCollectionRequest The desired configuration for the collection. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The collection has been successfully created. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. The request body included invalid request parameters. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> Payment required. Organization is on a paid plan and is delinquent on payment. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> You&#39;ve exceed your collections quota. </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Collection of given name already exists. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity. The request body could not be deserialized. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createCollectionAsync(CreateCollectionRequest createCollectionRequest, final ApiCallback<CollectionModel> _callback) throws ApiException {

        okhttp3.Call localVarCall = createCollectionValidateBeforeCall(createCollectionRequest, _callback);
        Type localVarReturnType = new TypeToken<CollectionModel>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for createIndex
     * @param createIndexRequest The desired configuration for the index. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The index has been successfully created. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. The request body included invalid request parameters. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> Payment required. Organization is on a paid plan and is delinquent on payment. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> You&#39;ve exceed your pod quota. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Unknown cloud or region when creating a serverless index. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity. The request body could not be deserialized. </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Index of given name already exists. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createIndexCall(CreateIndexRequest createIndexRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = createIndexRequest;

        // create path and map variables
        String localVarPath = "/indexes";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createIndexValidateBeforeCall(CreateIndexRequest createIndexRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'createIndexRequest' is set
        if (createIndexRequest == null) {
            throw new ApiException("Missing the required parameter 'createIndexRequest' when calling createIndex(Async)");
        }

        return createIndexCall(createIndexRequest, _callback);

    }

    /**
     * Create an index
     * Create a Pinecone index. This is where you specify the measure of similarity, the dimension of vectors to be stored in the index, which cloud provider you would like to deploy with, and more.    For guidance and examples, see [Create an index](https://docs.pinecone.io/guides/indexes/create-an-index#create-a-serverless-index). 
     * @param createIndexRequest The desired configuration for the index. (required)
     * @return IndexModel
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The index has been successfully created. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. The request body included invalid request parameters. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> Payment required. Organization is on a paid plan and is delinquent on payment. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> You&#39;ve exceed your pod quota. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Unknown cloud or region when creating a serverless index. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity. The request body could not be deserialized. </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Index of given name already exists. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public IndexModel createIndex(CreateIndexRequest createIndexRequest) throws ApiException {
        ApiResponse<IndexModel> localVarResp = createIndexWithHttpInfo(createIndexRequest);
        return localVarResp.getData();
    }

    /**
     * Create an index
     * Create a Pinecone index. This is where you specify the measure of similarity, the dimension of vectors to be stored in the index, which cloud provider you would like to deploy with, and more.    For guidance and examples, see [Create an index](https://docs.pinecone.io/guides/indexes/create-an-index#create-a-serverless-index). 
     * @param createIndexRequest The desired configuration for the index. (required)
     * @return ApiResponse&lt;IndexModel&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The index has been successfully created. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. The request body included invalid request parameters. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> Payment required. Organization is on a paid plan and is delinquent on payment. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> You&#39;ve exceed your pod quota. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Unknown cloud or region when creating a serverless index. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity. The request body could not be deserialized. </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Index of given name already exists. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<IndexModel> createIndexWithHttpInfo(CreateIndexRequest createIndexRequest) throws ApiException {
        okhttp3.Call localVarCall = createIndexValidateBeforeCall(createIndexRequest, null);
        Type localVarReturnType = new TypeToken<IndexModel>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create an index (asynchronously)
     * Create a Pinecone index. This is where you specify the measure of similarity, the dimension of vectors to be stored in the index, which cloud provider you would like to deploy with, and more.    For guidance and examples, see [Create an index](https://docs.pinecone.io/guides/indexes/create-an-index#create-a-serverless-index). 
     * @param createIndexRequest The desired configuration for the index. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The index has been successfully created. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. The request body included invalid request parameters. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> Payment required. Organization is on a paid plan and is delinquent on payment. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> You&#39;ve exceed your pod quota. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Unknown cloud or region when creating a serverless index. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity. The request body could not be deserialized. </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Index of given name already exists. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createIndexAsync(CreateIndexRequest createIndexRequest, final ApiCallback<IndexModel> _callback) throws ApiException {

        okhttp3.Call localVarCall = createIndexValidateBeforeCall(createIndexRequest, _callback);
        Type localVarReturnType = new TypeToken<IndexModel>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for createIndexForModel
     * @param createIndexForModelRequest The desired configuration for the index and associated embedding model. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The index has successfully been created for the embedding model. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. The request body included invalid request parameters. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Unknown cloud or region when creating a serverless index. </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Index of given name already exists. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity. The request body could not be deserialized. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createIndexForModelCall(CreateIndexForModelRequest createIndexForModelRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = createIndexForModelRequest;

        // create path and map variables
        String localVarPath = "/indexes/create-for-model";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createIndexForModelValidateBeforeCall(CreateIndexForModelRequest createIndexForModelRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'createIndexForModelRequest' is set
        if (createIndexForModelRequest == null) {
            throw new ApiException("Missing the required parameter 'createIndexForModelRequest' when calling createIndexForModel(Async)");
        }

        return createIndexForModelCall(createIndexForModelRequest, _callback);

    }

    /**
     * Create an index with integrated embedding
     * Create an index with integrated embedding.  With this type of index, you provide source text, and Pinecone uses a [hosted embedding model](https://docs.pinecone.io/guides/inference/understanding-inference#embedding-models) to convert the text automatically during [upsert](https://docs.pinecone.io/reference/api/2025-01/data-plane/upsert_records) and [search](https://docs.pinecone.io/reference/api/2025-01/data-plane/search_records).  For guidance and examples, see [Create an index](https://docs.pinecone.io/guides/indexes/create-an-index#integrated-embedding).
     * @param createIndexForModelRequest The desired configuration for the index and associated embedding model. (required)
     * @return IndexModel
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The index has successfully been created for the embedding model. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. The request body included invalid request parameters. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Unknown cloud or region when creating a serverless index. </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Index of given name already exists. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity. The request body could not be deserialized. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public IndexModel createIndexForModel(CreateIndexForModelRequest createIndexForModelRequest) throws ApiException {
        ApiResponse<IndexModel> localVarResp = createIndexForModelWithHttpInfo(createIndexForModelRequest);
        return localVarResp.getData();
    }

    /**
     * Create an index with integrated embedding
     * Create an index with integrated embedding.  With this type of index, you provide source text, and Pinecone uses a [hosted embedding model](https://docs.pinecone.io/guides/inference/understanding-inference#embedding-models) to convert the text automatically during [upsert](https://docs.pinecone.io/reference/api/2025-01/data-plane/upsert_records) and [search](https://docs.pinecone.io/reference/api/2025-01/data-plane/search_records).  For guidance and examples, see [Create an index](https://docs.pinecone.io/guides/indexes/create-an-index#integrated-embedding).
     * @param createIndexForModelRequest The desired configuration for the index and associated embedding model. (required)
     * @return ApiResponse&lt;IndexModel&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The index has successfully been created for the embedding model. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. The request body included invalid request parameters. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Unknown cloud or region when creating a serverless index. </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Index of given name already exists. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity. The request body could not be deserialized. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<IndexModel> createIndexForModelWithHttpInfo(CreateIndexForModelRequest createIndexForModelRequest) throws ApiException {
        okhttp3.Call localVarCall = createIndexForModelValidateBeforeCall(createIndexForModelRequest, null);
        Type localVarReturnType = new TypeToken<IndexModel>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create an index with integrated embedding (asynchronously)
     * Create an index with integrated embedding.  With this type of index, you provide source text, and Pinecone uses a [hosted embedding model](https://docs.pinecone.io/guides/inference/understanding-inference#embedding-models) to convert the text automatically during [upsert](https://docs.pinecone.io/reference/api/2025-01/data-plane/upsert_records) and [search](https://docs.pinecone.io/reference/api/2025-01/data-plane/search_records).  For guidance and examples, see [Create an index](https://docs.pinecone.io/guides/indexes/create-an-index#integrated-embedding).
     * @param createIndexForModelRequest The desired configuration for the index and associated embedding model. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The index has successfully been created for the embedding model. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. The request body included invalid request parameters. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Unknown cloud or region when creating a serverless index. </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Index of given name already exists. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity. The request body could not be deserialized. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createIndexForModelAsync(CreateIndexForModelRequest createIndexForModelRequest, final ApiCallback<IndexModel> _callback) throws ApiException {

        okhttp3.Call localVarCall = createIndexForModelValidateBeforeCall(createIndexForModelRequest, _callback);
        Type localVarReturnType = new TypeToken<IndexModel>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for createIndexFromBackup
     * @param backupId The ID of the backup to create an index from. (required)
     * @param createIndexFromBackupRequest The desired configuration for the index created from a backup. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The request to create the index has been accepted. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. The request body included invalid request parameters. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> Payment required. Organization is on a paid plan and is delinquent on payment. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> You&#39;ve exceed your pod quota. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Backup not found. </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Index of given name already exists. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity. The request body could not be deserialized. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createIndexFromBackupCall(String backupId, CreateIndexFromBackupRequest createIndexFromBackupRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = createIndexFromBackupRequest;

        // create path and map variables
        String localVarPath = "/backups/{backup_id}/create-index"
            .replace("{" + "backup_id" + "}", localVarApiClient.escapeString(backupId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createIndexFromBackupValidateBeforeCall(String backupId, CreateIndexFromBackupRequest createIndexFromBackupRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'backupId' is set
        if (backupId == null) {
            throw new ApiException("Missing the required parameter 'backupId' when calling createIndexFromBackup(Async)");
        }

        // verify the required parameter 'createIndexFromBackupRequest' is set
        if (createIndexFromBackupRequest == null) {
            throw new ApiException("Missing the required parameter 'createIndexFromBackupRequest' when calling createIndexFromBackup(Async)");
        }

        return createIndexFromBackupCall(backupId, createIndexFromBackupRequest, _callback);

    }

    /**
     * Create an index from a backup
     * Create an index from a backup.
     * @param backupId The ID of the backup to create an index from. (required)
     * @param createIndexFromBackupRequest The desired configuration for the index created from a backup. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The request to create the index has been accepted. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. The request body included invalid request parameters. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> Payment required. Organization is on a paid plan and is delinquent on payment. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> You&#39;ve exceed your pod quota. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Backup not found. </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Index of given name already exists. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity. The request body could not be deserialized. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public void createIndexFromBackup(String backupId, CreateIndexFromBackupRequest createIndexFromBackupRequest) throws ApiException {
        createIndexFromBackupWithHttpInfo(backupId, createIndexFromBackupRequest);
    }

    /**
     * Create an index from a backup
     * Create an index from a backup.
     * @param backupId The ID of the backup to create an index from. (required)
     * @param createIndexFromBackupRequest The desired configuration for the index created from a backup. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The request to create the index has been accepted. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. The request body included invalid request parameters. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> Payment required. Organization is on a paid plan and is delinquent on payment. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> You&#39;ve exceed your pod quota. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Backup not found. </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Index of given name already exists. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity. The request body could not be deserialized. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> createIndexFromBackupWithHttpInfo(String backupId, CreateIndexFromBackupRequest createIndexFromBackupRequest) throws ApiException {
        okhttp3.Call localVarCall = createIndexFromBackupValidateBeforeCall(backupId, createIndexFromBackupRequest, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Create an index from a backup (asynchronously)
     * Create an index from a backup.
     * @param backupId The ID of the backup to create an index from. (required)
     * @param createIndexFromBackupRequest The desired configuration for the index created from a backup. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The request to create the index has been accepted. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. The request body included invalid request parameters. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> Payment required. Organization is on a paid plan and is delinquent on payment. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> You&#39;ve exceed your pod quota. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Backup not found. </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Index of given name already exists. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity. The request body could not be deserialized. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createIndexFromBackupAsync(String backupId, CreateIndexFromBackupRequest createIndexFromBackupRequest, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = createIndexFromBackupValidateBeforeCall(backupId, createIndexFromBackupRequest, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteBackup
     * @param backupId The ID of the backup to delete. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The request to delete the backup has been accepted. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Backup not found. </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> There is a pending restore job created from this backup. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteBackupCall(String backupId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/backups/{backup_id}"
            .replace("{" + "backup_id" + "}", localVarApiClient.escapeString(backupId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteBackupValidateBeforeCall(String backupId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'backupId' is set
        if (backupId == null) {
            throw new ApiException("Missing the required parameter 'backupId' when calling deleteBackup(Async)");
        }

        return deleteBackupCall(backupId, _callback);

    }

    /**
     * Delete a backup
     * Delete a backup.
     * @param backupId The ID of the backup to delete. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The request to delete the backup has been accepted. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Backup not found. </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> There is a pending restore job created from this backup. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public void deleteBackup(String backupId) throws ApiException {
        deleteBackupWithHttpInfo(backupId);
    }

    /**
     * Delete a backup
     * Delete a backup.
     * @param backupId The ID of the backup to delete. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The request to delete the backup has been accepted. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Backup not found. </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> There is a pending restore job created from this backup. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> deleteBackupWithHttpInfo(String backupId) throws ApiException {
        okhttp3.Call localVarCall = deleteBackupValidateBeforeCall(backupId, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Delete a backup (asynchronously)
     * Delete a backup.
     * @param backupId The ID of the backup to delete. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The request to delete the backup has been accepted. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Backup not found. </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> There is a pending restore job created from this backup. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteBackupAsync(String backupId, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteBackupValidateBeforeCall(backupId, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteCollection
     * @param collectionName The name of the collection. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The collection has been successfully deleted. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Collection not found. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteCollectionCall(String collectionName, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/collections/{collection_name}"
            .replace("{" + "collection_name" + "}", localVarApiClient.escapeString(collectionName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteCollectionValidateBeforeCall(String collectionName, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'collectionName' is set
        if (collectionName == null) {
            throw new ApiException("Missing the required parameter 'collectionName' when calling deleteCollection(Async)");
        }

        return deleteCollectionCall(collectionName, _callback);

    }

    /**
     * Delete a collection
     * Delete an existing collection. Serverless indexes do not support collections. 
     * @param collectionName The name of the collection. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The collection has been successfully deleted. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Collection not found. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public void deleteCollection(String collectionName) throws ApiException {
        deleteCollectionWithHttpInfo(collectionName);
    }

    /**
     * Delete a collection
     * Delete an existing collection. Serverless indexes do not support collections. 
     * @param collectionName The name of the collection. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The collection has been successfully deleted. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Collection not found. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> deleteCollectionWithHttpInfo(String collectionName) throws ApiException {
        okhttp3.Call localVarCall = deleteCollectionValidateBeforeCall(collectionName, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Delete a collection (asynchronously)
     * Delete an existing collection. Serverless indexes do not support collections. 
     * @param collectionName The name of the collection. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The collection has been successfully deleted. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Collection not found. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteCollectionAsync(String collectionName, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteCollectionValidateBeforeCall(collectionName, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteIndex
     * @param indexName The name of the index to delete. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The request to delete the index has been accepted. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden. Deletion protection enabled. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Index not found. </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> There is a pending collection created from this index. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteIndexCall(String indexName, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/indexes/{index_name}"
            .replace("{" + "index_name" + "}", localVarApiClient.escapeString(indexName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteIndexValidateBeforeCall(String indexName, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'indexName' is set
        if (indexName == null) {
            throw new ApiException("Missing the required parameter 'indexName' when calling deleteIndex(Async)");
        }

        return deleteIndexCall(indexName, _callback);

    }

    /**
     * Delete an index
     * Delete an existing index.
     * @param indexName The name of the index to delete. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The request to delete the index has been accepted. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden. Deletion protection enabled. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Index not found. </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> There is a pending collection created from this index. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public void deleteIndex(String indexName) throws ApiException {
        deleteIndexWithHttpInfo(indexName);
    }

    /**
     * Delete an index
     * Delete an existing index.
     * @param indexName The name of the index to delete. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The request to delete the index has been accepted. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden. Deletion protection enabled. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Index not found. </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> There is a pending collection created from this index. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> deleteIndexWithHttpInfo(String indexName) throws ApiException {
        okhttp3.Call localVarCall = deleteIndexValidateBeforeCall(indexName, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Delete an index (asynchronously)
     * Delete an existing index.
     * @param indexName The name of the index to delete. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The request to delete the index has been accepted. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden. Deletion protection enabled. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Index not found. </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> There is a pending collection created from this index. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteIndexAsync(String indexName, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteIndexValidateBeforeCall(indexName, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for describeBackup
     * @param backupId The ID of the backup to describe. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Configuration information and deployment status of the backup. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Backup not found. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call describeBackupCall(String backupId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/backups/{backup_id}"
            .replace("{" + "backup_id" + "}", localVarApiClient.escapeString(backupId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call describeBackupValidateBeforeCall(String backupId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'backupId' is set
        if (backupId == null) {
            throw new ApiException("Missing the required parameter 'backupId' when calling describeBackup(Async)");
        }

        return describeBackupCall(backupId, _callback);

    }

    /**
     * Describe a backup
     * Get a description of a backup.
     * @param backupId The ID of the backup to describe. (required)
     * @return BackupModel
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Configuration information and deployment status of the backup. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Backup not found. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public BackupModel describeBackup(String backupId) throws ApiException {
        ApiResponse<BackupModel> localVarResp = describeBackupWithHttpInfo(backupId);
        return localVarResp.getData();
    }

    /**
     * Describe a backup
     * Get a description of a backup.
     * @param backupId The ID of the backup to describe. (required)
     * @return ApiResponse&lt;BackupModel&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Configuration information and deployment status of the backup. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Backup not found. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<BackupModel> describeBackupWithHttpInfo(String backupId) throws ApiException {
        okhttp3.Call localVarCall = describeBackupValidateBeforeCall(backupId, null);
        Type localVarReturnType = new TypeToken<BackupModel>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Describe a backup (asynchronously)
     * Get a description of a backup.
     * @param backupId The ID of the backup to describe. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Configuration information and deployment status of the backup. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Backup not found. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call describeBackupAsync(String backupId, final ApiCallback<BackupModel> _callback) throws ApiException {

        okhttp3.Call localVarCall = describeBackupValidateBeforeCall(backupId, _callback);
        Type localVarReturnType = new TypeToken<BackupModel>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for describeCollection
     * @param collectionName The name of the collection to be described. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Configuration information and status of the collection. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Collection not found. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call describeCollectionCall(String collectionName, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/collections/{collection_name}"
            .replace("{" + "collection_name" + "}", localVarApiClient.escapeString(collectionName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call describeCollectionValidateBeforeCall(String collectionName, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'collectionName' is set
        if (collectionName == null) {
            throw new ApiException("Missing the required parameter 'collectionName' when calling describeCollection(Async)");
        }

        return describeCollectionCall(collectionName, _callback);

    }

    /**
     * Describe a collection
     * Get a description of a collection. Serverless indexes do not support collections. 
     * @param collectionName The name of the collection to be described. (required)
     * @return CollectionModel
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Configuration information and status of the collection. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Collection not found. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public CollectionModel describeCollection(String collectionName) throws ApiException {
        ApiResponse<CollectionModel> localVarResp = describeCollectionWithHttpInfo(collectionName);
        return localVarResp.getData();
    }

    /**
     * Describe a collection
     * Get a description of a collection. Serverless indexes do not support collections. 
     * @param collectionName The name of the collection to be described. (required)
     * @return ApiResponse&lt;CollectionModel&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Configuration information and status of the collection. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Collection not found. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CollectionModel> describeCollectionWithHttpInfo(String collectionName) throws ApiException {
        okhttp3.Call localVarCall = describeCollectionValidateBeforeCall(collectionName, null);
        Type localVarReturnType = new TypeToken<CollectionModel>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Describe a collection (asynchronously)
     * Get a description of a collection. Serverless indexes do not support collections. 
     * @param collectionName The name of the collection to be described. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Configuration information and status of the collection. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Collection not found. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call describeCollectionAsync(String collectionName, final ApiCallback<CollectionModel> _callback) throws ApiException {

        okhttp3.Call localVarCall = describeCollectionValidateBeforeCall(collectionName, _callback);
        Type localVarReturnType = new TypeToken<CollectionModel>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for describeIndex
     * @param indexName The name of the index to be described. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Configuration information and deployment status of the index. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Index not found. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call describeIndexCall(String indexName, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/indexes/{index_name}"
            .replace("{" + "index_name" + "}", localVarApiClient.escapeString(indexName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call describeIndexValidateBeforeCall(String indexName, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'indexName' is set
        if (indexName == null) {
            throw new ApiException("Missing the required parameter 'indexName' when calling describeIndex(Async)");
        }

        return describeIndexCall(indexName, _callback);

    }

    /**
     * Describe an index
     * Get a description of an index.
     * @param indexName The name of the index to be described. (required)
     * @return IndexModel
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Configuration information and deployment status of the index. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Index not found. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public IndexModel describeIndex(String indexName) throws ApiException {
        ApiResponse<IndexModel> localVarResp = describeIndexWithHttpInfo(indexName);
        return localVarResp.getData();
    }

    /**
     * Describe an index
     * Get a description of an index.
     * @param indexName The name of the index to be described. (required)
     * @return ApiResponse&lt;IndexModel&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Configuration information and deployment status of the index. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Index not found. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<IndexModel> describeIndexWithHttpInfo(String indexName) throws ApiException {
        okhttp3.Call localVarCall = describeIndexValidateBeforeCall(indexName, null);
        Type localVarReturnType = new TypeToken<IndexModel>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Describe an index (asynchronously)
     * Get a description of an index.
     * @param indexName The name of the index to be described. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Configuration information and deployment status of the index. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Index not found. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call describeIndexAsync(String indexName, final ApiCallback<IndexModel> _callback) throws ApiException {

        okhttp3.Call localVarCall = describeIndexValidateBeforeCall(indexName, _callback);
        Type localVarReturnType = new TypeToken<IndexModel>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for describeRestoreJob
     * @param jobId The ID of the restore job to describe. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Configuration information and deployment status of the restore job. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Restore job not found. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call describeRestoreJobCall(String jobId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/restore-jobs/{job_id}"
            .replace("{" + "job_id" + "}", localVarApiClient.escapeString(jobId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call describeRestoreJobValidateBeforeCall(String jobId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'jobId' is set
        if (jobId == null) {
            throw new ApiException("Missing the required parameter 'jobId' when calling describeRestoreJob(Async)");
        }

        return describeRestoreJobCall(jobId, _callback);

    }

    /**
     * Describe a restore job
     * Get a description of a restore job.
     * @param jobId The ID of the restore job to describe. (required)
     * @return RestoreJobModel
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Configuration information and deployment status of the restore job. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Restore job not found. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public RestoreJobModel describeRestoreJob(String jobId) throws ApiException {
        ApiResponse<RestoreJobModel> localVarResp = describeRestoreJobWithHttpInfo(jobId);
        return localVarResp.getData();
    }

    /**
     * Describe a restore job
     * Get a description of a restore job.
     * @param jobId The ID of the restore job to describe. (required)
     * @return ApiResponse&lt;RestoreJobModel&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Configuration information and deployment status of the restore job. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Restore job not found. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RestoreJobModel> describeRestoreJobWithHttpInfo(String jobId) throws ApiException {
        okhttp3.Call localVarCall = describeRestoreJobValidateBeforeCall(jobId, null);
        Type localVarReturnType = new TypeToken<RestoreJobModel>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Describe a restore job (asynchronously)
     * Get a description of a restore job.
     * @param jobId The ID of the restore job to describe. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Configuration information and deployment status of the restore job. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Restore job not found. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call describeRestoreJobAsync(String jobId, final ApiCallback<RestoreJobModel> _callback) throws ApiException {

        okhttp3.Call localVarCall = describeRestoreJobValidateBeforeCall(jobId, _callback);
        Type localVarReturnType = new TypeToken<RestoreJobModel>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for listCollections
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List all the collections in your current project. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listCollectionsCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/collections";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listCollectionsValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        return listCollectionsCall(_callback);

    }

    /**
     * List collections
     * List all collections in a project. Serverless indexes do not support collections. 
     * @return CollectionList
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List all the collections in your current project. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public CollectionList listCollections() throws ApiException {
        ApiResponse<CollectionList> localVarResp = listCollectionsWithHttpInfo();
        return localVarResp.getData();
    }

    /**
     * List collections
     * List all collections in a project. Serverless indexes do not support collections. 
     * @return ApiResponse&lt;CollectionList&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List all the collections in your current project. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CollectionList> listCollectionsWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = listCollectionsValidateBeforeCall(null);
        Type localVarReturnType = new TypeToken<CollectionList>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List collections (asynchronously)
     * List all collections in a project. Serverless indexes do not support collections. 
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List all the collections in your current project. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listCollectionsAsync(final ApiCallback<CollectionList> _callback) throws ApiException {

        okhttp3.Call localVarCall = listCollectionsValidateBeforeCall(_callback);
        Type localVarReturnType = new TypeToken<CollectionList>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for listIndexBackups
     * @param indexName Name of the backed up index (required)
     * @param limit The number of results to return per page. (optional, default to 10)
     * @param paginationToken The token to use to retrieve the next page of results. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> This operation returns a list of all the backups that you have previously created, and which are associated with the given index. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Index not found. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listIndexBackupsCall(String indexName, Integer limit, String paginationToken, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/indexes/{index_name}/backups"
            .replace("{" + "index_name" + "}", localVarApiClient.escapeString(indexName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (paginationToken != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("paginationToken", paginationToken));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listIndexBackupsValidateBeforeCall(String indexName, Integer limit, String paginationToken, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'indexName' is set
        if (indexName == null) {
            throw new ApiException("Missing the required parameter 'indexName' when calling listIndexBackups(Async)");
        }

        return listIndexBackupsCall(indexName, limit, paginationToken, _callback);

    }

    /**
     * List backups for an index
     * List all backups for an index.
     * @param indexName Name of the backed up index (required)
     * @param limit The number of results to return per page. (optional, default to 10)
     * @param paginationToken The token to use to retrieve the next page of results. (optional)
     * @return BackupList
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> This operation returns a list of all the backups that you have previously created, and which are associated with the given index. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Index not found. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public BackupList listIndexBackups(String indexName, Integer limit, String paginationToken) throws ApiException {
        ApiResponse<BackupList> localVarResp = listIndexBackupsWithHttpInfo(indexName, limit, paginationToken);
        return localVarResp.getData();
    }

    /**
     * List backups for an index
     * List all backups for an index.
     * @param indexName Name of the backed up index (required)
     * @param limit The number of results to return per page. (optional, default to 10)
     * @param paginationToken The token to use to retrieve the next page of results. (optional)
     * @return ApiResponse&lt;BackupList&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> This operation returns a list of all the backups that you have previously created, and which are associated with the given index. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Index not found. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<BackupList> listIndexBackupsWithHttpInfo(String indexName, Integer limit, String paginationToken) throws ApiException {
        okhttp3.Call localVarCall = listIndexBackupsValidateBeforeCall(indexName, limit, paginationToken, null);
        Type localVarReturnType = new TypeToken<BackupList>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List backups for an index (asynchronously)
     * List all backups for an index.
     * @param indexName Name of the backed up index (required)
     * @param limit The number of results to return per page. (optional, default to 10)
     * @param paginationToken The token to use to retrieve the next page of results. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> This operation returns a list of all the backups that you have previously created, and which are associated with the given index. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Index not found. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listIndexBackupsAsync(String indexName, Integer limit, String paginationToken, final ApiCallback<BackupList> _callback) throws ApiException {

        okhttp3.Call localVarCall = listIndexBackupsValidateBeforeCall(indexName, limit, paginationToken, _callback);
        Type localVarReturnType = new TypeToken<BackupList>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for listIndexes
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> This operation returns a list of all the indexes that you have previously created, and which are associated with the given project </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listIndexesCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/indexes";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listIndexesValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        return listIndexesCall(_callback);

    }

    /**
     * List indexes
     * List all indexes in a project.
     * @return IndexList
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> This operation returns a list of all the indexes that you have previously created, and which are associated with the given project </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public IndexList listIndexes() throws ApiException {
        ApiResponse<IndexList> localVarResp = listIndexesWithHttpInfo();
        return localVarResp.getData();
    }

    /**
     * List indexes
     * List all indexes in a project.
     * @return ApiResponse&lt;IndexList&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> This operation returns a list of all the indexes that you have previously created, and which are associated with the given project </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<IndexList> listIndexesWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = listIndexesValidateBeforeCall(null);
        Type localVarReturnType = new TypeToken<IndexList>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List indexes (asynchronously)
     * List all indexes in a project.
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> This operation returns a list of all the indexes that you have previously created, and which are associated with the given project </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listIndexesAsync(final ApiCallback<IndexList> _callback) throws ApiException {

        okhttp3.Call localVarCall = listIndexesValidateBeforeCall(_callback);
        Type localVarReturnType = new TypeToken<IndexList>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for listProjectBackups
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> This operation returns a list of all the backups for the given index that you have previously created. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listProjectBackupsCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/backups";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listProjectBackupsValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        return listProjectBackupsCall(_callback);

    }

    /**
     * List backups for all indexes in a project
     * List all backups for a project.
     * @return BackupList
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> This operation returns a list of all the backups for the given index that you have previously created. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public BackupList listProjectBackups() throws ApiException {
        ApiResponse<BackupList> localVarResp = listProjectBackupsWithHttpInfo();
        return localVarResp.getData();
    }

    /**
     * List backups for all indexes in a project
     * List all backups for a project.
     * @return ApiResponse&lt;BackupList&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> This operation returns a list of all the backups for the given index that you have previously created. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<BackupList> listProjectBackupsWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = listProjectBackupsValidateBeforeCall(null);
        Type localVarReturnType = new TypeToken<BackupList>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List backups for all indexes in a project (asynchronously)
     * List all backups for a project.
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> This operation returns a list of all the backups for the given index that you have previously created. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listProjectBackupsAsync(final ApiCallback<BackupList> _callback) throws ApiException {

        okhttp3.Call localVarCall = listProjectBackupsValidateBeforeCall(_callback);
        Type localVarReturnType = new TypeToken<BackupList>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for listRestoreJobs
     * @param limit The number of results to return per page. (optional, default to 10)
     * @param paginationToken The token to use to retrieve the next page of results. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> This operation returns a list of all the restore jobs that you have previously created. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listRestoreJobsCall(Integer limit, String paginationToken, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/restore-jobs";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (paginationToken != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("paginationToken", paginationToken));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listRestoreJobsValidateBeforeCall(Integer limit, String paginationToken, final ApiCallback _callback) throws ApiException {
        return listRestoreJobsCall(limit, paginationToken, _callback);

    }

    /**
     * List restore jobs
     * List all restore jobs for a project.
     * @param limit The number of results to return per page. (optional, default to 10)
     * @param paginationToken The token to use to retrieve the next page of results. (optional)
     * @return RestoreJobList
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> This operation returns a list of all the restore jobs that you have previously created. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public RestoreJobList listRestoreJobs(Integer limit, String paginationToken) throws ApiException {
        ApiResponse<RestoreJobList> localVarResp = listRestoreJobsWithHttpInfo(limit, paginationToken);
        return localVarResp.getData();
    }

    /**
     * List restore jobs
     * List all restore jobs for a project.
     * @param limit The number of results to return per page. (optional, default to 10)
     * @param paginationToken The token to use to retrieve the next page of results. (optional)
     * @return ApiResponse&lt;RestoreJobList&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> This operation returns a list of all the restore jobs that you have previously created. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RestoreJobList> listRestoreJobsWithHttpInfo(Integer limit, String paginationToken) throws ApiException {
        okhttp3.Call localVarCall = listRestoreJobsValidateBeforeCall(limit, paginationToken, null);
        Type localVarReturnType = new TypeToken<RestoreJobList>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List restore jobs (asynchronously)
     * List all restore jobs for a project.
     * @param limit The number of results to return per page. (optional, default to 10)
     * @param paginationToken The token to use to retrieve the next page of results. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> This operation returns a list of all the restore jobs that you have previously created. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listRestoreJobsAsync(Integer limit, String paginationToken, final ApiCallback<RestoreJobList> _callback) throws ApiException {

        okhttp3.Call localVarCall = listRestoreJobsValidateBeforeCall(limit, paginationToken, _callback);
        Type localVarReturnType = new TypeToken<RestoreJobList>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
