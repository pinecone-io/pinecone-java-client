/*
 * Pinecone Control Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-10
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.db_control.client.api;

import org.openapitools.db_control.client.ApiCallback;
import org.openapitools.db_control.client.ApiClient;
import org.openapitools.db_control.client.ApiException;
import org.openapitools.db_control.client.ApiResponse;
import org.openapitools.db_control.client.Configuration;
import org.openapitools.db_control.client.Pair;
import org.openapitools.db_control.client.ProgressRequestBody;
import org.openapitools.db_control.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.db_control.client.model.BackupList;
import org.openapitools.db_control.client.model.BackupModel;
import org.openapitools.db_control.client.model.CollectionList;
import org.openapitools.db_control.client.model.CollectionModel;
import org.openapitools.db_control.client.model.ConfigureIndexRequest;
import org.openapitools.db_control.client.model.CreateBackupRequest;
import org.openapitools.db_control.client.model.CreateCollectionRequest;
import org.openapitools.db_control.client.model.CreateIndexForModelRequest;
import org.openapitools.db_control.client.model.CreateIndexFromBackupRequest;
import org.openapitools.db_control.client.model.CreateIndexFromBackupResponse;
import org.openapitools.db_control.client.model.CreateIndexRequest;
import org.openapitools.db_control.client.model.ErrorResponse;
import org.openapitools.db_control.client.model.IndexList;
import org.openapitools.db_control.client.model.IndexModel;
import org.openapitools.db_control.client.model.RestoreJobList;
import org.openapitools.db_control.client.model.RestoreJobModel;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class ManageIndexesApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public ManageIndexesApi() {
        this(Configuration.getDefaultApiClient());
    }

    public ManageIndexesApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for configureIndex
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param indexName The name of the index to configure. (required)
     * @param configureIndexRequest The desired pod size and replica configuration for the index. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The request to configure the index has been accepted. Check the  index status to see when the change has been applied. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. The request body included invalid request parameters. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> Payment required. Organization is on a paid plan and is delinquent on payment. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> You&#39;ve exceed your pod quota. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Index not found. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity. The request body could not be deserialized. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call configureIndexCall(String xPineconeApiVersion, String indexName, ConfigureIndexRequest configureIndexRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = configureIndexRequest;

        // create path and map variables
        String localVarPath = "/indexes/{index_name}"
            .replace("{" + "index_name" + "}", localVarApiClient.escapeString(indexName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (xPineconeApiVersion != null) {
            localVarHeaderParams.put("X-Pinecone-Api-Version", localVarApiClient.parameterToString(xPineconeApiVersion));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PATCH", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call configureIndexValidateBeforeCall(String xPineconeApiVersion, String indexName, ConfigureIndexRequest configureIndexRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xPineconeApiVersion' is set
        if (xPineconeApiVersion == null) {
            throw new ApiException("Missing the required parameter 'xPineconeApiVersion' when calling configureIndex(Async)");
        }

        // verify the required parameter 'indexName' is set
        if (indexName == null) {
            throw new ApiException("Missing the required parameter 'indexName' when calling configureIndex(Async)");
        }

        // verify the required parameter 'configureIndexRequest' is set
        if (configureIndexRequest == null) {
            throw new ApiException("Missing the required parameter 'configureIndexRequest' when calling configureIndex(Async)");
        }

        return configureIndexCall(xPineconeApiVersion, indexName, configureIndexRequest, _callback);

    }

    /**
     * Configure an index
     * Configure an existing index. For serverless indexes, you can configure index deletion protection, tags, and integrated inference embedding settings for the index. For pod-based indexes, you can configure the pod size, number of replicas, tags, and index deletion protection.  It is not possible to change the pod type of a pod-based index. However, you can create a collection from a pod-based index and then [create a new pod-based index with a different pod type](http://docs.pinecone.io/guides/indexes/pods/create-a-pod-based-index#create-a-pod-index-from-a-collection) from the collection. For guidance and examples, see [Configure an index](http://docs.pinecone.io/guides/indexes/pods/manage-pod-based-indexes).
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param indexName The name of the index to configure. (required)
     * @param configureIndexRequest The desired pod size and replica configuration for the index. (required)
     * @return IndexModel
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The request to configure the index has been accepted. Check the  index status to see when the change has been applied. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. The request body included invalid request parameters. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> Payment required. Organization is on a paid plan and is delinquent on payment. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> You&#39;ve exceed your pod quota. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Index not found. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity. The request body could not be deserialized. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public IndexModel configureIndex(String xPineconeApiVersion, String indexName, ConfigureIndexRequest configureIndexRequest) throws ApiException {
        ApiResponse<IndexModel> localVarResp = configureIndexWithHttpInfo(xPineconeApiVersion, indexName, configureIndexRequest);
        return localVarResp.getData();
    }

    /**
     * Configure an index
     * Configure an existing index. For serverless indexes, you can configure index deletion protection, tags, and integrated inference embedding settings for the index. For pod-based indexes, you can configure the pod size, number of replicas, tags, and index deletion protection.  It is not possible to change the pod type of a pod-based index. However, you can create a collection from a pod-based index and then [create a new pod-based index with a different pod type](http://docs.pinecone.io/guides/indexes/pods/create-a-pod-based-index#create-a-pod-index-from-a-collection) from the collection. For guidance and examples, see [Configure an index](http://docs.pinecone.io/guides/indexes/pods/manage-pod-based-indexes).
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param indexName The name of the index to configure. (required)
     * @param configureIndexRequest The desired pod size and replica configuration for the index. (required)
     * @return ApiResponse&lt;IndexModel&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The request to configure the index has been accepted. Check the  index status to see when the change has been applied. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. The request body included invalid request parameters. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> Payment required. Organization is on a paid plan and is delinquent on payment. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> You&#39;ve exceed your pod quota. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Index not found. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity. The request body could not be deserialized. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<IndexModel> configureIndexWithHttpInfo(String xPineconeApiVersion, String indexName, ConfigureIndexRequest configureIndexRequest) throws ApiException {
        okhttp3.Call localVarCall = configureIndexValidateBeforeCall(xPineconeApiVersion, indexName, configureIndexRequest, null);
        Type localVarReturnType = new TypeToken<IndexModel>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Configure an index (asynchronously)
     * Configure an existing index. For serverless indexes, you can configure index deletion protection, tags, and integrated inference embedding settings for the index. For pod-based indexes, you can configure the pod size, number of replicas, tags, and index deletion protection.  It is not possible to change the pod type of a pod-based index. However, you can create a collection from a pod-based index and then [create a new pod-based index with a different pod type](http://docs.pinecone.io/guides/indexes/pods/create-a-pod-based-index#create-a-pod-index-from-a-collection) from the collection. For guidance and examples, see [Configure an index](http://docs.pinecone.io/guides/indexes/pods/manage-pod-based-indexes).
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param indexName The name of the index to configure. (required)
     * @param configureIndexRequest The desired pod size and replica configuration for the index. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The request to configure the index has been accepted. Check the  index status to see when the change has been applied. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. The request body included invalid request parameters. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> Payment required. Organization is on a paid plan and is delinquent on payment. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> You&#39;ve exceed your pod quota. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Index not found. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity. The request body could not be deserialized. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call configureIndexAsync(String xPineconeApiVersion, String indexName, ConfigureIndexRequest configureIndexRequest, final ApiCallback<IndexModel> _callback) throws ApiException {

        okhttp3.Call localVarCall = configureIndexValidateBeforeCall(xPineconeApiVersion, indexName, configureIndexRequest, _callback);
        Type localVarReturnType = new TypeToken<IndexModel>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for createBackup
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param indexName Name of the index to backup (required)
     * @param createBackupRequest The desired configuration for the backup. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The backup has been successfully created. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. The request body included invalid request parameters. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> Payment required. Organization is on a paid plan and is delinquent on payment. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> You&#39;ve exceed your backup quota. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity. The request body could not be deserialized. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createBackupCall(String xPineconeApiVersion, String indexName, CreateBackupRequest createBackupRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = createBackupRequest;

        // create path and map variables
        String localVarPath = "/indexes/{index_name}/backups"
            .replace("{" + "index_name" + "}", localVarApiClient.escapeString(indexName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (xPineconeApiVersion != null) {
            localVarHeaderParams.put("X-Pinecone-Api-Version", localVarApiClient.parameterToString(xPineconeApiVersion));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createBackupValidateBeforeCall(String xPineconeApiVersion, String indexName, CreateBackupRequest createBackupRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xPineconeApiVersion' is set
        if (xPineconeApiVersion == null) {
            throw new ApiException("Missing the required parameter 'xPineconeApiVersion' when calling createBackup(Async)");
        }

        // verify the required parameter 'indexName' is set
        if (indexName == null) {
            throw new ApiException("Missing the required parameter 'indexName' when calling createBackup(Async)");
        }

        // verify the required parameter 'createBackupRequest' is set
        if (createBackupRequest == null) {
            throw new ApiException("Missing the required parameter 'createBackupRequest' when calling createBackup(Async)");
        }

        return createBackupCall(xPineconeApiVersion, indexName, createBackupRequest, _callback);

    }

    /**
     * Create a backup of an index
     * Create a backup of an index. 
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param indexName Name of the index to backup (required)
     * @param createBackupRequest The desired configuration for the backup. (required)
     * @return BackupModel
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The backup has been successfully created. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. The request body included invalid request parameters. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> Payment required. Organization is on a paid plan and is delinquent on payment. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> You&#39;ve exceed your backup quota. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity. The request body could not be deserialized. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public BackupModel createBackup(String xPineconeApiVersion, String indexName, CreateBackupRequest createBackupRequest) throws ApiException {
        ApiResponse<BackupModel> localVarResp = createBackupWithHttpInfo(xPineconeApiVersion, indexName, createBackupRequest);
        return localVarResp.getData();
    }

    /**
     * Create a backup of an index
     * Create a backup of an index. 
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param indexName Name of the index to backup (required)
     * @param createBackupRequest The desired configuration for the backup. (required)
     * @return ApiResponse&lt;BackupModel&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The backup has been successfully created. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. The request body included invalid request parameters. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> Payment required. Organization is on a paid plan and is delinquent on payment. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> You&#39;ve exceed your backup quota. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity. The request body could not be deserialized. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<BackupModel> createBackupWithHttpInfo(String xPineconeApiVersion, String indexName, CreateBackupRequest createBackupRequest) throws ApiException {
        okhttp3.Call localVarCall = createBackupValidateBeforeCall(xPineconeApiVersion, indexName, createBackupRequest, null);
        Type localVarReturnType = new TypeToken<BackupModel>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create a backup of an index (asynchronously)
     * Create a backup of an index. 
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param indexName Name of the index to backup (required)
     * @param createBackupRequest The desired configuration for the backup. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The backup has been successfully created. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. The request body included invalid request parameters. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> Payment required. Organization is on a paid plan and is delinquent on payment. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> You&#39;ve exceed your backup quota. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity. The request body could not be deserialized. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createBackupAsync(String xPineconeApiVersion, String indexName, CreateBackupRequest createBackupRequest, final ApiCallback<BackupModel> _callback) throws ApiException {

        okhttp3.Call localVarCall = createBackupValidateBeforeCall(xPineconeApiVersion, indexName, createBackupRequest, _callback);
        Type localVarReturnType = new TypeToken<BackupModel>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for createCollection
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param createCollectionRequest The desired configuration for the collection. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The collection has been successfully created. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. The request body included invalid request parameters. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> Payment required. Organization is on a paid plan and is delinquent on payment. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> You&#39;ve exceed your collections quota. </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Collection of given name already exists. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity. The request body could not be deserialized. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createCollectionCall(String xPineconeApiVersion, CreateCollectionRequest createCollectionRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = createCollectionRequest;

        // create path and map variables
        String localVarPath = "/collections";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (xPineconeApiVersion != null) {
            localVarHeaderParams.put("X-Pinecone-Api-Version", localVarApiClient.parameterToString(xPineconeApiVersion));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createCollectionValidateBeforeCall(String xPineconeApiVersion, CreateCollectionRequest createCollectionRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xPineconeApiVersion' is set
        if (xPineconeApiVersion == null) {
            throw new ApiException("Missing the required parameter 'xPineconeApiVersion' when calling createCollection(Async)");
        }

        // verify the required parameter 'createCollectionRequest' is set
        if (createCollectionRequest == null) {
            throw new ApiException("Missing the required parameter 'createCollectionRequest' when calling createCollection(Async)");
        }

        return createCollectionCall(xPineconeApiVersion, createCollectionRequest, _callback);

    }

    /**
     * Create a collection
     * Create a Pinecone collection.    Serverless indexes do not support collections. 
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param createCollectionRequest The desired configuration for the collection. (required)
     * @return CollectionModel
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The collection has been successfully created. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. The request body included invalid request parameters. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> Payment required. Organization is on a paid plan and is delinquent on payment. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> You&#39;ve exceed your collections quota. </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Collection of given name already exists. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity. The request body could not be deserialized. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public CollectionModel createCollection(String xPineconeApiVersion, CreateCollectionRequest createCollectionRequest) throws ApiException {
        ApiResponse<CollectionModel> localVarResp = createCollectionWithHttpInfo(xPineconeApiVersion, createCollectionRequest);
        return localVarResp.getData();
    }

    /**
     * Create a collection
     * Create a Pinecone collection.    Serverless indexes do not support collections. 
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param createCollectionRequest The desired configuration for the collection. (required)
     * @return ApiResponse&lt;CollectionModel&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The collection has been successfully created. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. The request body included invalid request parameters. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> Payment required. Organization is on a paid plan and is delinquent on payment. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> You&#39;ve exceed your collections quota. </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Collection of given name already exists. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity. The request body could not be deserialized. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CollectionModel> createCollectionWithHttpInfo(String xPineconeApiVersion, CreateCollectionRequest createCollectionRequest) throws ApiException {
        okhttp3.Call localVarCall = createCollectionValidateBeforeCall(xPineconeApiVersion, createCollectionRequest, null);
        Type localVarReturnType = new TypeToken<CollectionModel>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create a collection (asynchronously)
     * Create a Pinecone collection.    Serverless indexes do not support collections. 
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param createCollectionRequest The desired configuration for the collection. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The collection has been successfully created. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. The request body included invalid request parameters. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> Payment required. Organization is on a paid plan and is delinquent on payment. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> You&#39;ve exceed your collections quota. </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Collection of given name already exists. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity. The request body could not be deserialized. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createCollectionAsync(String xPineconeApiVersion, CreateCollectionRequest createCollectionRequest, final ApiCallback<CollectionModel> _callback) throws ApiException {

        okhttp3.Call localVarCall = createCollectionValidateBeforeCall(xPineconeApiVersion, createCollectionRequest, _callback);
        Type localVarReturnType = new TypeToken<CollectionModel>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for createIndex
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param createIndexRequest The desired configuration for the index. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The index has been successfully created. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. The request body included invalid request parameters. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> Payment required. Organization is on a paid plan and is delinquent on payment. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> You&#39;ve exceed your pod quota. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Unknown cloud or region when creating a serverless index. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity. The request body could not be deserialized. </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Index of given name already exists. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createIndexCall(String xPineconeApiVersion, CreateIndexRequest createIndexRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = createIndexRequest;

        // create path and map variables
        String localVarPath = "/indexes";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (xPineconeApiVersion != null) {
            localVarHeaderParams.put("X-Pinecone-Api-Version", localVarApiClient.parameterToString(xPineconeApiVersion));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createIndexValidateBeforeCall(String xPineconeApiVersion, CreateIndexRequest createIndexRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xPineconeApiVersion' is set
        if (xPineconeApiVersion == null) {
            throw new ApiException("Missing the required parameter 'xPineconeApiVersion' when calling createIndex(Async)");
        }

        // verify the required parameter 'createIndexRequest' is set
        if (createIndexRequest == null) {
            throw new ApiException("Missing the required parameter 'createIndexRequest' when calling createIndex(Async)");
        }

        return createIndexCall(xPineconeApiVersion, createIndexRequest, _callback);

    }

    /**
     * Create an index
     * Create a Pinecone index. This is where you specify the measure of similarity, the dimension of vectors to be stored in the index, which cloud provider you would like to deploy with, and more.    For guidance and examples, see [Create an index](https://docs.pinecone.io/guides/index-data/create-an-index). 
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param createIndexRequest The desired configuration for the index. (required)
     * @return IndexModel
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The index has been successfully created. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. The request body included invalid request parameters. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> Payment required. Organization is on a paid plan and is delinquent on payment. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> You&#39;ve exceed your pod quota. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Unknown cloud or region when creating a serverless index. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity. The request body could not be deserialized. </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Index of given name already exists. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public IndexModel createIndex(String xPineconeApiVersion, CreateIndexRequest createIndexRequest) throws ApiException {
        ApiResponse<IndexModel> localVarResp = createIndexWithHttpInfo(xPineconeApiVersion, createIndexRequest);
        return localVarResp.getData();
    }

    /**
     * Create an index
     * Create a Pinecone index. This is where you specify the measure of similarity, the dimension of vectors to be stored in the index, which cloud provider you would like to deploy with, and more.    For guidance and examples, see [Create an index](https://docs.pinecone.io/guides/index-data/create-an-index). 
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param createIndexRequest The desired configuration for the index. (required)
     * @return ApiResponse&lt;IndexModel&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The index has been successfully created. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. The request body included invalid request parameters. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> Payment required. Organization is on a paid plan and is delinquent on payment. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> You&#39;ve exceed your pod quota. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Unknown cloud or region when creating a serverless index. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity. The request body could not be deserialized. </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Index of given name already exists. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<IndexModel> createIndexWithHttpInfo(String xPineconeApiVersion, CreateIndexRequest createIndexRequest) throws ApiException {
        okhttp3.Call localVarCall = createIndexValidateBeforeCall(xPineconeApiVersion, createIndexRequest, null);
        Type localVarReturnType = new TypeToken<IndexModel>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create an index (asynchronously)
     * Create a Pinecone index. This is where you specify the measure of similarity, the dimension of vectors to be stored in the index, which cloud provider you would like to deploy with, and more.    For guidance and examples, see [Create an index](https://docs.pinecone.io/guides/index-data/create-an-index). 
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param createIndexRequest The desired configuration for the index. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The index has been successfully created. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. The request body included invalid request parameters. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> Payment required. Organization is on a paid plan and is delinquent on payment. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> You&#39;ve exceed your pod quota. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Unknown cloud or region when creating a serverless index. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity. The request body could not be deserialized. </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Index of given name already exists. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createIndexAsync(String xPineconeApiVersion, CreateIndexRequest createIndexRequest, final ApiCallback<IndexModel> _callback) throws ApiException {

        okhttp3.Call localVarCall = createIndexValidateBeforeCall(xPineconeApiVersion, createIndexRequest, _callback);
        Type localVarReturnType = new TypeToken<IndexModel>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for createIndexForModel
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param createIndexForModelRequest The desired configuration for the index and associated embedding model. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The index has successfully been created for the embedding model. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. The request body included invalid request parameters. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Unknown cloud or region when creating a serverless index. </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Index of given name already exists. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity. The request body could not be deserialized. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createIndexForModelCall(String xPineconeApiVersion, CreateIndexForModelRequest createIndexForModelRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = createIndexForModelRequest;

        // create path and map variables
        String localVarPath = "/indexes/create-for-model";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (xPineconeApiVersion != null) {
            localVarHeaderParams.put("X-Pinecone-Api-Version", localVarApiClient.parameterToString(xPineconeApiVersion));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createIndexForModelValidateBeforeCall(String xPineconeApiVersion, CreateIndexForModelRequest createIndexForModelRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xPineconeApiVersion' is set
        if (xPineconeApiVersion == null) {
            throw new ApiException("Missing the required parameter 'xPineconeApiVersion' when calling createIndexForModel(Async)");
        }

        // verify the required parameter 'createIndexForModelRequest' is set
        if (createIndexForModelRequest == null) {
            throw new ApiException("Missing the required parameter 'createIndexForModelRequest' when calling createIndexForModel(Async)");
        }

        return createIndexForModelCall(xPineconeApiVersion, createIndexForModelRequest, _callback);

    }

    /**
     * Create an index with integrated embedding
     * Create an index with integrated embedding. With this type of index, you provide source text, and  Pinecone uses a [hosted embedding model](https://docs.pinecone.io/guides/index-data/create-an-index#embedding-models)  to convert the text automatically during [upsert](https://docs.pinecone.io/reference/api/2025-10/data-plane/upsert_records)  and [search](https://docs.pinecone.io/reference/api/2025-10/data-plane/search_records).   For guidance and examples, see [Create an index](https://docs.pinecone.io/guides/index-data/create-an-index#integrated-embedding).
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param createIndexForModelRequest The desired configuration for the index and associated embedding model. (required)
     * @return IndexModel
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The index has successfully been created for the embedding model. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. The request body included invalid request parameters. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Unknown cloud or region when creating a serverless index. </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Index of given name already exists. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity. The request body could not be deserialized. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public IndexModel createIndexForModel(String xPineconeApiVersion, CreateIndexForModelRequest createIndexForModelRequest) throws ApiException {
        ApiResponse<IndexModel> localVarResp = createIndexForModelWithHttpInfo(xPineconeApiVersion, createIndexForModelRequest);
        return localVarResp.getData();
    }

    /**
     * Create an index with integrated embedding
     * Create an index with integrated embedding. With this type of index, you provide source text, and  Pinecone uses a [hosted embedding model](https://docs.pinecone.io/guides/index-data/create-an-index#embedding-models)  to convert the text automatically during [upsert](https://docs.pinecone.io/reference/api/2025-10/data-plane/upsert_records)  and [search](https://docs.pinecone.io/reference/api/2025-10/data-plane/search_records).   For guidance and examples, see [Create an index](https://docs.pinecone.io/guides/index-data/create-an-index#integrated-embedding).
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param createIndexForModelRequest The desired configuration for the index and associated embedding model. (required)
     * @return ApiResponse&lt;IndexModel&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The index has successfully been created for the embedding model. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. The request body included invalid request parameters. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Unknown cloud or region when creating a serverless index. </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Index of given name already exists. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity. The request body could not be deserialized. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<IndexModel> createIndexForModelWithHttpInfo(String xPineconeApiVersion, CreateIndexForModelRequest createIndexForModelRequest) throws ApiException {
        okhttp3.Call localVarCall = createIndexForModelValidateBeforeCall(xPineconeApiVersion, createIndexForModelRequest, null);
        Type localVarReturnType = new TypeToken<IndexModel>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create an index with integrated embedding (asynchronously)
     * Create an index with integrated embedding. With this type of index, you provide source text, and  Pinecone uses a [hosted embedding model](https://docs.pinecone.io/guides/index-data/create-an-index#embedding-models)  to convert the text automatically during [upsert](https://docs.pinecone.io/reference/api/2025-10/data-plane/upsert_records)  and [search](https://docs.pinecone.io/reference/api/2025-10/data-plane/search_records).   For guidance and examples, see [Create an index](https://docs.pinecone.io/guides/index-data/create-an-index#integrated-embedding).
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param createIndexForModelRequest The desired configuration for the index and associated embedding model. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The index has successfully been created for the embedding model. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. The request body included invalid request parameters. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Unknown cloud or region when creating a serverless index. </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Index of given name already exists. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity. The request body could not be deserialized. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createIndexForModelAsync(String xPineconeApiVersion, CreateIndexForModelRequest createIndexForModelRequest, final ApiCallback<IndexModel> _callback) throws ApiException {

        okhttp3.Call localVarCall = createIndexForModelValidateBeforeCall(xPineconeApiVersion, createIndexForModelRequest, _callback);
        Type localVarReturnType = new TypeToken<IndexModel>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for createIndexFromBackupOperation
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param backupId The ID of the backup to create an index from. (required)
     * @param createIndexFromBackupRequest The desired configuration for the index created from a backup. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The request to create the index has been accepted. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. The request body included invalid request parameters. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> Payment required. Organization is on a paid plan and is delinquent on payment. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> You&#39;ve exceed your pod quota. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Backup not found. </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Index of given name already exists. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity. The request body could not be deserialized. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createIndexFromBackupOperationCall(String xPineconeApiVersion, String backupId, CreateIndexFromBackupRequest createIndexFromBackupRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = createIndexFromBackupRequest;

        // create path and map variables
        String localVarPath = "/backups/{backup_id}/create-index"
            .replace("{" + "backup_id" + "}", localVarApiClient.escapeString(backupId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (xPineconeApiVersion != null) {
            localVarHeaderParams.put("X-Pinecone-Api-Version", localVarApiClient.parameterToString(xPineconeApiVersion));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createIndexFromBackupOperationValidateBeforeCall(String xPineconeApiVersion, String backupId, CreateIndexFromBackupRequest createIndexFromBackupRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xPineconeApiVersion' is set
        if (xPineconeApiVersion == null) {
            throw new ApiException("Missing the required parameter 'xPineconeApiVersion' when calling createIndexFromBackupOperation(Async)");
        }

        // verify the required parameter 'backupId' is set
        if (backupId == null) {
            throw new ApiException("Missing the required parameter 'backupId' when calling createIndexFromBackupOperation(Async)");
        }

        // verify the required parameter 'createIndexFromBackupRequest' is set
        if (createIndexFromBackupRequest == null) {
            throw new ApiException("Missing the required parameter 'createIndexFromBackupRequest' when calling createIndexFromBackupOperation(Async)");
        }

        return createIndexFromBackupOperationCall(xPineconeApiVersion, backupId, createIndexFromBackupRequest, _callback);

    }

    /**
     * Create an index from a backup
     * Create an index from a backup.
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param backupId The ID of the backup to create an index from. (required)
     * @param createIndexFromBackupRequest The desired configuration for the index created from a backup. (required)
     * @return CreateIndexFromBackupResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The request to create the index has been accepted. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. The request body included invalid request parameters. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> Payment required. Organization is on a paid plan and is delinquent on payment. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> You&#39;ve exceed your pod quota. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Backup not found. </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Index of given name already exists. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity. The request body could not be deserialized. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public CreateIndexFromBackupResponse createIndexFromBackupOperation(String xPineconeApiVersion, String backupId, CreateIndexFromBackupRequest createIndexFromBackupRequest) throws ApiException {
        ApiResponse<CreateIndexFromBackupResponse> localVarResp = createIndexFromBackupOperationWithHttpInfo(xPineconeApiVersion, backupId, createIndexFromBackupRequest);
        return localVarResp.getData();
    }

    /**
     * Create an index from a backup
     * Create an index from a backup.
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param backupId The ID of the backup to create an index from. (required)
     * @param createIndexFromBackupRequest The desired configuration for the index created from a backup. (required)
     * @return ApiResponse&lt;CreateIndexFromBackupResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The request to create the index has been accepted. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. The request body included invalid request parameters. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> Payment required. Organization is on a paid plan and is delinquent on payment. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> You&#39;ve exceed your pod quota. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Backup not found. </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Index of given name already exists. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity. The request body could not be deserialized. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CreateIndexFromBackupResponse> createIndexFromBackupOperationWithHttpInfo(String xPineconeApiVersion, String backupId, CreateIndexFromBackupRequest createIndexFromBackupRequest) throws ApiException {
        okhttp3.Call localVarCall = createIndexFromBackupOperationValidateBeforeCall(xPineconeApiVersion, backupId, createIndexFromBackupRequest, null);
        Type localVarReturnType = new TypeToken<CreateIndexFromBackupResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create an index from a backup (asynchronously)
     * Create an index from a backup.
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param backupId The ID of the backup to create an index from. (required)
     * @param createIndexFromBackupRequest The desired configuration for the index created from a backup. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The request to create the index has been accepted. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad request. The request body included invalid request parameters. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> Payment required. Organization is on a paid plan and is delinquent on payment. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> You&#39;ve exceed your pod quota. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Backup not found. </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Index of given name already exists. </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Unprocessable entity. The request body could not be deserialized. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createIndexFromBackupOperationAsync(String xPineconeApiVersion, String backupId, CreateIndexFromBackupRequest createIndexFromBackupRequest, final ApiCallback<CreateIndexFromBackupResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = createIndexFromBackupOperationValidateBeforeCall(xPineconeApiVersion, backupId, createIndexFromBackupRequest, _callback);
        Type localVarReturnType = new TypeToken<CreateIndexFromBackupResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteBackup
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param backupId The ID of the backup to delete. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The request to delete the backup has been accepted. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Backup not found. </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> There is a pending restore job created from this backup. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteBackupCall(String xPineconeApiVersion, String backupId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/backups/{backup_id}"
            .replace("{" + "backup_id" + "}", localVarApiClient.escapeString(backupId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (xPineconeApiVersion != null) {
            localVarHeaderParams.put("X-Pinecone-Api-Version", localVarApiClient.parameterToString(xPineconeApiVersion));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteBackupValidateBeforeCall(String xPineconeApiVersion, String backupId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xPineconeApiVersion' is set
        if (xPineconeApiVersion == null) {
            throw new ApiException("Missing the required parameter 'xPineconeApiVersion' when calling deleteBackup(Async)");
        }

        // verify the required parameter 'backupId' is set
        if (backupId == null) {
            throw new ApiException("Missing the required parameter 'backupId' when calling deleteBackup(Async)");
        }

        return deleteBackupCall(xPineconeApiVersion, backupId, _callback);

    }

    /**
     * Delete a backup
     * Delete a backup.
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param backupId The ID of the backup to delete. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The request to delete the backup has been accepted. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Backup not found. </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> There is a pending restore job created from this backup. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public void deleteBackup(String xPineconeApiVersion, String backupId) throws ApiException {
        deleteBackupWithHttpInfo(xPineconeApiVersion, backupId);
    }

    /**
     * Delete a backup
     * Delete a backup.
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param backupId The ID of the backup to delete. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The request to delete the backup has been accepted. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Backup not found. </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> There is a pending restore job created from this backup. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> deleteBackupWithHttpInfo(String xPineconeApiVersion, String backupId) throws ApiException {
        okhttp3.Call localVarCall = deleteBackupValidateBeforeCall(xPineconeApiVersion, backupId, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Delete a backup (asynchronously)
     * Delete a backup.
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param backupId The ID of the backup to delete. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The request to delete the backup has been accepted. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Backup not found. </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> There is a pending restore job created from this backup. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteBackupAsync(String xPineconeApiVersion, String backupId, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteBackupValidateBeforeCall(xPineconeApiVersion, backupId, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteCollection
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param collectionName The name of the collection. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The collection has been successfully deleted. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Collection not found. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteCollectionCall(String xPineconeApiVersion, String collectionName, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/collections/{collection_name}"
            .replace("{" + "collection_name" + "}", localVarApiClient.escapeString(collectionName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (xPineconeApiVersion != null) {
            localVarHeaderParams.put("X-Pinecone-Api-Version", localVarApiClient.parameterToString(xPineconeApiVersion));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteCollectionValidateBeforeCall(String xPineconeApiVersion, String collectionName, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xPineconeApiVersion' is set
        if (xPineconeApiVersion == null) {
            throw new ApiException("Missing the required parameter 'xPineconeApiVersion' when calling deleteCollection(Async)");
        }

        // verify the required parameter 'collectionName' is set
        if (collectionName == null) {
            throw new ApiException("Missing the required parameter 'collectionName' when calling deleteCollection(Async)");
        }

        return deleteCollectionCall(xPineconeApiVersion, collectionName, _callback);

    }

    /**
     * Delete a collection
     * Delete an existing collection. Serverless indexes do not support collections. 
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param collectionName The name of the collection. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The collection has been successfully deleted. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Collection not found. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public void deleteCollection(String xPineconeApiVersion, String collectionName) throws ApiException {
        deleteCollectionWithHttpInfo(xPineconeApiVersion, collectionName);
    }

    /**
     * Delete a collection
     * Delete an existing collection. Serverless indexes do not support collections. 
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param collectionName The name of the collection. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The collection has been successfully deleted. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Collection not found. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> deleteCollectionWithHttpInfo(String xPineconeApiVersion, String collectionName) throws ApiException {
        okhttp3.Call localVarCall = deleteCollectionValidateBeforeCall(xPineconeApiVersion, collectionName, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Delete a collection (asynchronously)
     * Delete an existing collection. Serverless indexes do not support collections. 
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param collectionName The name of the collection. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The collection has been successfully deleted. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Collection not found. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteCollectionAsync(String xPineconeApiVersion, String collectionName, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteCollectionValidateBeforeCall(xPineconeApiVersion, collectionName, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteIndex
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param indexName The name of the index to delete. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The request to delete the index has been accepted. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden. Deletion protection enabled. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Index not found. </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> There is a pending collection created from this index. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteIndexCall(String xPineconeApiVersion, String indexName, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/indexes/{index_name}"
            .replace("{" + "index_name" + "}", localVarApiClient.escapeString(indexName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (xPineconeApiVersion != null) {
            localVarHeaderParams.put("X-Pinecone-Api-Version", localVarApiClient.parameterToString(xPineconeApiVersion));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteIndexValidateBeforeCall(String xPineconeApiVersion, String indexName, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xPineconeApiVersion' is set
        if (xPineconeApiVersion == null) {
            throw new ApiException("Missing the required parameter 'xPineconeApiVersion' when calling deleteIndex(Async)");
        }

        // verify the required parameter 'indexName' is set
        if (indexName == null) {
            throw new ApiException("Missing the required parameter 'indexName' when calling deleteIndex(Async)");
        }

        return deleteIndexCall(xPineconeApiVersion, indexName, _callback);

    }

    /**
     * Delete an index
     * Delete an existing index.
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param indexName The name of the index to delete. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The request to delete the index has been accepted. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden. Deletion protection enabled. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Index not found. </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> There is a pending collection created from this index. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public void deleteIndex(String xPineconeApiVersion, String indexName) throws ApiException {
        deleteIndexWithHttpInfo(xPineconeApiVersion, indexName);
    }

    /**
     * Delete an index
     * Delete an existing index.
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param indexName The name of the index to delete. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The request to delete the index has been accepted. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden. Deletion protection enabled. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Index not found. </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> There is a pending collection created from this index. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> deleteIndexWithHttpInfo(String xPineconeApiVersion, String indexName) throws ApiException {
        okhttp3.Call localVarCall = deleteIndexValidateBeforeCall(xPineconeApiVersion, indexName, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Delete an index (asynchronously)
     * Delete an existing index.
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param indexName The name of the index to delete. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> The request to delete the index has been accepted. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden. Deletion protection enabled. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Index not found. </td><td>  -  </td></tr>
        <tr><td> 412 </td><td> There is a pending collection created from this index. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteIndexAsync(String xPineconeApiVersion, String indexName, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteIndexValidateBeforeCall(xPineconeApiVersion, indexName, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for describeBackup
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param backupId The ID of the backup to describe. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Configuration information and deployment status of the backup. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Backup not found. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call describeBackupCall(String xPineconeApiVersion, String backupId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/backups/{backup_id}"
            .replace("{" + "backup_id" + "}", localVarApiClient.escapeString(backupId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (xPineconeApiVersion != null) {
            localVarHeaderParams.put("X-Pinecone-Api-Version", localVarApiClient.parameterToString(xPineconeApiVersion));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call describeBackupValidateBeforeCall(String xPineconeApiVersion, String backupId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xPineconeApiVersion' is set
        if (xPineconeApiVersion == null) {
            throw new ApiException("Missing the required parameter 'xPineconeApiVersion' when calling describeBackup(Async)");
        }

        // verify the required parameter 'backupId' is set
        if (backupId == null) {
            throw new ApiException("Missing the required parameter 'backupId' when calling describeBackup(Async)");
        }

        return describeBackupCall(xPineconeApiVersion, backupId, _callback);

    }

    /**
     * Describe a backup
     * Get a description of a backup.
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param backupId The ID of the backup to describe. (required)
     * @return BackupModel
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Configuration information and deployment status of the backup. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Backup not found. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public BackupModel describeBackup(String xPineconeApiVersion, String backupId) throws ApiException {
        ApiResponse<BackupModel> localVarResp = describeBackupWithHttpInfo(xPineconeApiVersion, backupId);
        return localVarResp.getData();
    }

    /**
     * Describe a backup
     * Get a description of a backup.
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param backupId The ID of the backup to describe. (required)
     * @return ApiResponse&lt;BackupModel&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Configuration information and deployment status of the backup. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Backup not found. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<BackupModel> describeBackupWithHttpInfo(String xPineconeApiVersion, String backupId) throws ApiException {
        okhttp3.Call localVarCall = describeBackupValidateBeforeCall(xPineconeApiVersion, backupId, null);
        Type localVarReturnType = new TypeToken<BackupModel>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Describe a backup (asynchronously)
     * Get a description of a backup.
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param backupId The ID of the backup to describe. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Configuration information and deployment status of the backup. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Backup not found. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call describeBackupAsync(String xPineconeApiVersion, String backupId, final ApiCallback<BackupModel> _callback) throws ApiException {

        okhttp3.Call localVarCall = describeBackupValidateBeforeCall(xPineconeApiVersion, backupId, _callback);
        Type localVarReturnType = new TypeToken<BackupModel>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for describeCollection
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param collectionName The name of the collection to be described. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Configuration information and status of the collection. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Collection not found. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call describeCollectionCall(String xPineconeApiVersion, String collectionName, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/collections/{collection_name}"
            .replace("{" + "collection_name" + "}", localVarApiClient.escapeString(collectionName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (xPineconeApiVersion != null) {
            localVarHeaderParams.put("X-Pinecone-Api-Version", localVarApiClient.parameterToString(xPineconeApiVersion));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call describeCollectionValidateBeforeCall(String xPineconeApiVersion, String collectionName, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xPineconeApiVersion' is set
        if (xPineconeApiVersion == null) {
            throw new ApiException("Missing the required parameter 'xPineconeApiVersion' when calling describeCollection(Async)");
        }

        // verify the required parameter 'collectionName' is set
        if (collectionName == null) {
            throw new ApiException("Missing the required parameter 'collectionName' when calling describeCollection(Async)");
        }

        return describeCollectionCall(xPineconeApiVersion, collectionName, _callback);

    }

    /**
     * Describe a collection
     * Get a description of a collection. Serverless indexes do not support collections. 
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param collectionName The name of the collection to be described. (required)
     * @return CollectionModel
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Configuration information and status of the collection. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Collection not found. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public CollectionModel describeCollection(String xPineconeApiVersion, String collectionName) throws ApiException {
        ApiResponse<CollectionModel> localVarResp = describeCollectionWithHttpInfo(xPineconeApiVersion, collectionName);
        return localVarResp.getData();
    }

    /**
     * Describe a collection
     * Get a description of a collection. Serverless indexes do not support collections. 
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param collectionName The name of the collection to be described. (required)
     * @return ApiResponse&lt;CollectionModel&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Configuration information and status of the collection. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Collection not found. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CollectionModel> describeCollectionWithHttpInfo(String xPineconeApiVersion, String collectionName) throws ApiException {
        okhttp3.Call localVarCall = describeCollectionValidateBeforeCall(xPineconeApiVersion, collectionName, null);
        Type localVarReturnType = new TypeToken<CollectionModel>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Describe a collection (asynchronously)
     * Get a description of a collection. Serverless indexes do not support collections. 
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param collectionName The name of the collection to be described. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Configuration information and status of the collection. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Collection not found. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call describeCollectionAsync(String xPineconeApiVersion, String collectionName, final ApiCallback<CollectionModel> _callback) throws ApiException {

        okhttp3.Call localVarCall = describeCollectionValidateBeforeCall(xPineconeApiVersion, collectionName, _callback);
        Type localVarReturnType = new TypeToken<CollectionModel>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for describeIndex
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param indexName The name of the index to be described. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Configuration information and deployment status of the index. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Index not found. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call describeIndexCall(String xPineconeApiVersion, String indexName, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/indexes/{index_name}"
            .replace("{" + "index_name" + "}", localVarApiClient.escapeString(indexName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (xPineconeApiVersion != null) {
            localVarHeaderParams.put("X-Pinecone-Api-Version", localVarApiClient.parameterToString(xPineconeApiVersion));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call describeIndexValidateBeforeCall(String xPineconeApiVersion, String indexName, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xPineconeApiVersion' is set
        if (xPineconeApiVersion == null) {
            throw new ApiException("Missing the required parameter 'xPineconeApiVersion' when calling describeIndex(Async)");
        }

        // verify the required parameter 'indexName' is set
        if (indexName == null) {
            throw new ApiException("Missing the required parameter 'indexName' when calling describeIndex(Async)");
        }

        return describeIndexCall(xPineconeApiVersion, indexName, _callback);

    }

    /**
     * Describe an index
     * Get a description of an index.
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param indexName The name of the index to be described. (required)
     * @return IndexModel
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Configuration information and deployment status of the index. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Index not found. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public IndexModel describeIndex(String xPineconeApiVersion, String indexName) throws ApiException {
        ApiResponse<IndexModel> localVarResp = describeIndexWithHttpInfo(xPineconeApiVersion, indexName);
        return localVarResp.getData();
    }

    /**
     * Describe an index
     * Get a description of an index.
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param indexName The name of the index to be described. (required)
     * @return ApiResponse&lt;IndexModel&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Configuration information and deployment status of the index. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Index not found. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<IndexModel> describeIndexWithHttpInfo(String xPineconeApiVersion, String indexName) throws ApiException {
        okhttp3.Call localVarCall = describeIndexValidateBeforeCall(xPineconeApiVersion, indexName, null);
        Type localVarReturnType = new TypeToken<IndexModel>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Describe an index (asynchronously)
     * Get a description of an index.
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param indexName The name of the index to be described. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Configuration information and deployment status of the index. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Index not found. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call describeIndexAsync(String xPineconeApiVersion, String indexName, final ApiCallback<IndexModel> _callback) throws ApiException {

        okhttp3.Call localVarCall = describeIndexValidateBeforeCall(xPineconeApiVersion, indexName, _callback);
        Type localVarReturnType = new TypeToken<IndexModel>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for describeRestoreJob
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param jobId The ID of the restore job to describe. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Configuration information and deployment status of the restore job. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Restore job not found. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call describeRestoreJobCall(String xPineconeApiVersion, String jobId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/restore-jobs/{job_id}"
            .replace("{" + "job_id" + "}", localVarApiClient.escapeString(jobId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (xPineconeApiVersion != null) {
            localVarHeaderParams.put("X-Pinecone-Api-Version", localVarApiClient.parameterToString(xPineconeApiVersion));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call describeRestoreJobValidateBeforeCall(String xPineconeApiVersion, String jobId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xPineconeApiVersion' is set
        if (xPineconeApiVersion == null) {
            throw new ApiException("Missing the required parameter 'xPineconeApiVersion' when calling describeRestoreJob(Async)");
        }

        // verify the required parameter 'jobId' is set
        if (jobId == null) {
            throw new ApiException("Missing the required parameter 'jobId' when calling describeRestoreJob(Async)");
        }

        return describeRestoreJobCall(xPineconeApiVersion, jobId, _callback);

    }

    /**
     * Describe a restore job
     * Get a description of a restore job.
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param jobId The ID of the restore job to describe. (required)
     * @return RestoreJobModel
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Configuration information and deployment status of the restore job. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Restore job not found. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public RestoreJobModel describeRestoreJob(String xPineconeApiVersion, String jobId) throws ApiException {
        ApiResponse<RestoreJobModel> localVarResp = describeRestoreJobWithHttpInfo(xPineconeApiVersion, jobId);
        return localVarResp.getData();
    }

    /**
     * Describe a restore job
     * Get a description of a restore job.
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param jobId The ID of the restore job to describe. (required)
     * @return ApiResponse&lt;RestoreJobModel&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Configuration information and deployment status of the restore job. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Restore job not found. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RestoreJobModel> describeRestoreJobWithHttpInfo(String xPineconeApiVersion, String jobId) throws ApiException {
        okhttp3.Call localVarCall = describeRestoreJobValidateBeforeCall(xPineconeApiVersion, jobId, null);
        Type localVarReturnType = new TypeToken<RestoreJobModel>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Describe a restore job (asynchronously)
     * Get a description of a restore job.
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param jobId The ID of the restore job to describe. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Configuration information and deployment status of the restore job. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Restore job not found. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call describeRestoreJobAsync(String xPineconeApiVersion, String jobId, final ApiCallback<RestoreJobModel> _callback) throws ApiException {

        okhttp3.Call localVarCall = describeRestoreJobValidateBeforeCall(xPineconeApiVersion, jobId, _callback);
        Type localVarReturnType = new TypeToken<RestoreJobModel>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for listCollections
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List all the collections in your current project. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listCollectionsCall(String xPineconeApiVersion, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/collections";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (xPineconeApiVersion != null) {
            localVarHeaderParams.put("X-Pinecone-Api-Version", localVarApiClient.parameterToString(xPineconeApiVersion));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listCollectionsValidateBeforeCall(String xPineconeApiVersion, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xPineconeApiVersion' is set
        if (xPineconeApiVersion == null) {
            throw new ApiException("Missing the required parameter 'xPineconeApiVersion' when calling listCollections(Async)");
        }

        return listCollectionsCall(xPineconeApiVersion, _callback);

    }

    /**
     * List collections
     * List all collections in a project. Serverless indexes do not support collections. 
     * @param xPineconeApiVersion Required date-based version header (required)
     * @return CollectionList
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List all the collections in your current project. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public CollectionList listCollections(String xPineconeApiVersion) throws ApiException {
        ApiResponse<CollectionList> localVarResp = listCollectionsWithHttpInfo(xPineconeApiVersion);
        return localVarResp.getData();
    }

    /**
     * List collections
     * List all collections in a project. Serverless indexes do not support collections. 
     * @param xPineconeApiVersion Required date-based version header (required)
     * @return ApiResponse&lt;CollectionList&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List all the collections in your current project. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CollectionList> listCollectionsWithHttpInfo(String xPineconeApiVersion) throws ApiException {
        okhttp3.Call localVarCall = listCollectionsValidateBeforeCall(xPineconeApiVersion, null);
        Type localVarReturnType = new TypeToken<CollectionList>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List collections (asynchronously)
     * List all collections in a project. Serverless indexes do not support collections. 
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List all the collections in your current project. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listCollectionsAsync(String xPineconeApiVersion, final ApiCallback<CollectionList> _callback) throws ApiException {

        okhttp3.Call localVarCall = listCollectionsValidateBeforeCall(xPineconeApiVersion, _callback);
        Type localVarReturnType = new TypeToken<CollectionList>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for listIndexBackups
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param indexName Name of the backed up index (required)
     * @param limit The number of results to return per page. (optional, default to 10)
     * @param paginationToken The token to use to retrieve the next page of results. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> This operation returns a list of all the backups that you have previously created, and which are associated with the given index. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Index not found. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listIndexBackupsCall(String xPineconeApiVersion, String indexName, Integer limit, String paginationToken, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/indexes/{index_name}/backups"
            .replace("{" + "index_name" + "}", localVarApiClient.escapeString(indexName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (paginationToken != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("paginationToken", paginationToken));
        }

        if (xPineconeApiVersion != null) {
            localVarHeaderParams.put("X-Pinecone-Api-Version", localVarApiClient.parameterToString(xPineconeApiVersion));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listIndexBackupsValidateBeforeCall(String xPineconeApiVersion, String indexName, Integer limit, String paginationToken, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xPineconeApiVersion' is set
        if (xPineconeApiVersion == null) {
            throw new ApiException("Missing the required parameter 'xPineconeApiVersion' when calling listIndexBackups(Async)");
        }

        // verify the required parameter 'indexName' is set
        if (indexName == null) {
            throw new ApiException("Missing the required parameter 'indexName' when calling listIndexBackups(Async)");
        }

        return listIndexBackupsCall(xPineconeApiVersion, indexName, limit, paginationToken, _callback);

    }

    /**
     * List backups for an index
     * List all backups for an index.
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param indexName Name of the backed up index (required)
     * @param limit The number of results to return per page. (optional, default to 10)
     * @param paginationToken The token to use to retrieve the next page of results. (optional)
     * @return BackupList
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> This operation returns a list of all the backups that you have previously created, and which are associated with the given index. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Index not found. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public BackupList listIndexBackups(String xPineconeApiVersion, String indexName, Integer limit, String paginationToken) throws ApiException {
        ApiResponse<BackupList> localVarResp = listIndexBackupsWithHttpInfo(xPineconeApiVersion, indexName, limit, paginationToken);
        return localVarResp.getData();
    }

    /**
     * List backups for an index
     * List all backups for an index.
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param indexName Name of the backed up index (required)
     * @param limit The number of results to return per page. (optional, default to 10)
     * @param paginationToken The token to use to retrieve the next page of results. (optional)
     * @return ApiResponse&lt;BackupList&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> This operation returns a list of all the backups that you have previously created, and which are associated with the given index. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Index not found. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<BackupList> listIndexBackupsWithHttpInfo(String xPineconeApiVersion, String indexName, Integer limit, String paginationToken) throws ApiException {
        okhttp3.Call localVarCall = listIndexBackupsValidateBeforeCall(xPineconeApiVersion, indexName, limit, paginationToken, null);
        Type localVarReturnType = new TypeToken<BackupList>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List backups for an index (asynchronously)
     * List all backups for an index.
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param indexName Name of the backed up index (required)
     * @param limit The number of results to return per page. (optional, default to 10)
     * @param paginationToken The token to use to retrieve the next page of results. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> This operation returns a list of all the backups that you have previously created, and which are associated with the given index. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Index not found. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listIndexBackupsAsync(String xPineconeApiVersion, String indexName, Integer limit, String paginationToken, final ApiCallback<BackupList> _callback) throws ApiException {

        okhttp3.Call localVarCall = listIndexBackupsValidateBeforeCall(xPineconeApiVersion, indexName, limit, paginationToken, _callback);
        Type localVarReturnType = new TypeToken<BackupList>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for listIndexes
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> This operation returns a list of all the indexes that you have previously created, and which are associated with the given project </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listIndexesCall(String xPineconeApiVersion, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/indexes";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (xPineconeApiVersion != null) {
            localVarHeaderParams.put("X-Pinecone-Api-Version", localVarApiClient.parameterToString(xPineconeApiVersion));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listIndexesValidateBeforeCall(String xPineconeApiVersion, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xPineconeApiVersion' is set
        if (xPineconeApiVersion == null) {
            throw new ApiException("Missing the required parameter 'xPineconeApiVersion' when calling listIndexes(Async)");
        }

        return listIndexesCall(xPineconeApiVersion, _callback);

    }

    /**
     * List indexes
     * List all indexes in a project.
     * @param xPineconeApiVersion Required date-based version header (required)
     * @return IndexList
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> This operation returns a list of all the indexes that you have previously created, and which are associated with the given project </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public IndexList listIndexes(String xPineconeApiVersion) throws ApiException {
        ApiResponse<IndexList> localVarResp = listIndexesWithHttpInfo(xPineconeApiVersion);
        return localVarResp.getData();
    }

    /**
     * List indexes
     * List all indexes in a project.
     * @param xPineconeApiVersion Required date-based version header (required)
     * @return ApiResponse&lt;IndexList&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> This operation returns a list of all the indexes that you have previously created, and which are associated with the given project </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<IndexList> listIndexesWithHttpInfo(String xPineconeApiVersion) throws ApiException {
        okhttp3.Call localVarCall = listIndexesValidateBeforeCall(xPineconeApiVersion, null);
        Type localVarReturnType = new TypeToken<IndexList>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List indexes (asynchronously)
     * List all indexes in a project.
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> This operation returns a list of all the indexes that you have previously created, and which are associated with the given project </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listIndexesAsync(String xPineconeApiVersion, final ApiCallback<IndexList> _callback) throws ApiException {

        okhttp3.Call localVarCall = listIndexesValidateBeforeCall(xPineconeApiVersion, _callback);
        Type localVarReturnType = new TypeToken<IndexList>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for listProjectBackups
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param limit The number of results to return per page. (optional, default to 10)
     * @param paginationToken The token to use to retrieve the next page of results. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> This operation returns a list of all the backups for the given index that you have previously created. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listProjectBackupsCall(String xPineconeApiVersion, Integer limit, String paginationToken, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/backups";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (paginationToken != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("paginationToken", paginationToken));
        }

        if (xPineconeApiVersion != null) {
            localVarHeaderParams.put("X-Pinecone-Api-Version", localVarApiClient.parameterToString(xPineconeApiVersion));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listProjectBackupsValidateBeforeCall(String xPineconeApiVersion, Integer limit, String paginationToken, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xPineconeApiVersion' is set
        if (xPineconeApiVersion == null) {
            throw new ApiException("Missing the required parameter 'xPineconeApiVersion' when calling listProjectBackups(Async)");
        }

        return listProjectBackupsCall(xPineconeApiVersion, limit, paginationToken, _callback);

    }

    /**
     * List backups for all indexes in a project
     * List all backups for a project.
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param limit The number of results to return per page. (optional, default to 10)
     * @param paginationToken The token to use to retrieve the next page of results. (optional)
     * @return BackupList
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> This operation returns a list of all the backups for the given index that you have previously created. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public BackupList listProjectBackups(String xPineconeApiVersion, Integer limit, String paginationToken) throws ApiException {
        ApiResponse<BackupList> localVarResp = listProjectBackupsWithHttpInfo(xPineconeApiVersion, limit, paginationToken);
        return localVarResp.getData();
    }

    /**
     * List backups for all indexes in a project
     * List all backups for a project.
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param limit The number of results to return per page. (optional, default to 10)
     * @param paginationToken The token to use to retrieve the next page of results. (optional)
     * @return ApiResponse&lt;BackupList&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> This operation returns a list of all the backups for the given index that you have previously created. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<BackupList> listProjectBackupsWithHttpInfo(String xPineconeApiVersion, Integer limit, String paginationToken) throws ApiException {
        okhttp3.Call localVarCall = listProjectBackupsValidateBeforeCall(xPineconeApiVersion, limit, paginationToken, null);
        Type localVarReturnType = new TypeToken<BackupList>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List backups for all indexes in a project (asynchronously)
     * List all backups for a project.
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param limit The number of results to return per page. (optional, default to 10)
     * @param paginationToken The token to use to retrieve the next page of results. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> This operation returns a list of all the backups for the given index that you have previously created. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listProjectBackupsAsync(String xPineconeApiVersion, Integer limit, String paginationToken, final ApiCallback<BackupList> _callback) throws ApiException {

        okhttp3.Call localVarCall = listProjectBackupsValidateBeforeCall(xPineconeApiVersion, limit, paginationToken, _callback);
        Type localVarReturnType = new TypeToken<BackupList>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for listRestoreJobs
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param limit The number of results to return per page. (optional, default to 10)
     * @param paginationToken The token to use to retrieve the next page of results. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> This operation returns a list of all the restore jobs that you have previously created. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listRestoreJobsCall(String xPineconeApiVersion, Integer limit, String paginationToken, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/restore-jobs";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (paginationToken != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("paginationToken", paginationToken));
        }

        if (xPineconeApiVersion != null) {
            localVarHeaderParams.put("X-Pinecone-Api-Version", localVarApiClient.parameterToString(xPineconeApiVersion));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKeyAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listRestoreJobsValidateBeforeCall(String xPineconeApiVersion, Integer limit, String paginationToken, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xPineconeApiVersion' is set
        if (xPineconeApiVersion == null) {
            throw new ApiException("Missing the required parameter 'xPineconeApiVersion' when calling listRestoreJobs(Async)");
        }

        return listRestoreJobsCall(xPineconeApiVersion, limit, paginationToken, _callback);

    }

    /**
     * List restore jobs
     * List all restore jobs for a project.
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param limit The number of results to return per page. (optional, default to 10)
     * @param paginationToken The token to use to retrieve the next page of results. (optional)
     * @return RestoreJobList
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> This operation returns a list of all the restore jobs that you have previously created. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public RestoreJobList listRestoreJobs(String xPineconeApiVersion, Integer limit, String paginationToken) throws ApiException {
        ApiResponse<RestoreJobList> localVarResp = listRestoreJobsWithHttpInfo(xPineconeApiVersion, limit, paginationToken);
        return localVarResp.getData();
    }

    /**
     * List restore jobs
     * List all restore jobs for a project.
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param limit The number of results to return per page. (optional, default to 10)
     * @param paginationToken The token to use to retrieve the next page of results. (optional)
     * @return ApiResponse&lt;RestoreJobList&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> This operation returns a list of all the restore jobs that you have previously created. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RestoreJobList> listRestoreJobsWithHttpInfo(String xPineconeApiVersion, Integer limit, String paginationToken) throws ApiException {
        okhttp3.Call localVarCall = listRestoreJobsValidateBeforeCall(xPineconeApiVersion, limit, paginationToken, null);
        Type localVarReturnType = new TypeToken<RestoreJobList>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List restore jobs (asynchronously)
     * List all restore jobs for a project.
     * @param xPineconeApiVersion Required date-based version header (required)
     * @param limit The number of results to return per page. (optional, default to 10)
     * @param paginationToken The token to use to retrieve the next page of results. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> This operation returns a list of all the restore jobs that you have previously created. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized. Possible causes: Invalid API key. </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Internal server error. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listRestoreJobsAsync(String xPineconeApiVersion, Integer limit, String paginationToken, final ApiCallback<RestoreJobList> _callback) throws ApiException {

        okhttp3.Call localVarCall = listRestoreJobsValidateBeforeCall(xPineconeApiVersion, limit, paginationToken, _callback);
        Type localVarReturnType = new TypeToken<RestoreJobList>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
